<!DOCTYPE html>
<html>
<head>
<title>
	Shader Scene
</title>
<meta charset="utf-8" />
<meta
	name="viewport"
	content="width=device-width,
		user-scalable=no,
		minimum-scale=1.0,
		maximum-scale=1.0"
/>

<style>
	body
	{
		margin: 0px;
		background-color: #AAA;
		overflow: hidden;
	}
</style>
</head>

<body>
<script src="js/three.js"></script>
<script src="js/OBJLoader.js"></script>
<script type="text/javascript" src="js/dat.gui.min.js"></script>
<script type="text/javascript" src="js/options.js"></script>
<script type="x-shader/x-vertex" id="teamcolorVertexShader">
	precision mediump float;
	varying vec2 vUv;
	uniform int timeStamp;
	uniform bool beamOff;

	void main()
	{
		vUv = uv;
		float posx = position.x;
		float posy = position.y;
		float posz = position.z;
		if (beamOff)
		{
			posx = position.x * sin(mod(float(timeStamp) * 0.001, 3.0));
			posz = position.z * sin(mod(float(timeStamp) * 0.001, 3.0));
			posy = position.y * sin(mod(float(timeStamp) * 0.001, 3.0));
		}
		vec4 modelViewPosition = modelViewMatrix * vec4(posx, posy, posz, 1.0);
		gl_Position = projectionMatrix * modelViewPosition;
	}
</script>
<script type="x-shader/x-fragment" id="teamcolorFragmentShader">
	precision mediump float;
	uniform sampler2D textureKnight;
	uniform vec3 teamcolor;
	uniform int timeStamp;
	uniform bool beamOff;

	varying vec2 vUv;

	void main()
	{
		vec4 fragColor = texture2D(textureKnight, vUv);
		// fragColor.r = fragColor.r * abs(sin(float(timeStamp) * 0.001) + 0.2);
		// fragColor.g = fragColor.g * abs(sin(float(timeStamp) * 0.001) + 0.2);
		// fragColor.b = fragColor.b * abs(sin(float(timeStamp) * 0.001) + 0.2);
		if (beamOff)
		{
			fragColor.a = fragColor.a * abs(sin(float(timeStamp) * 0.001) + 0.2);
		}
		fragColor.r = fragColor.r * fragColor.a + teamcolor.r * ( 1.0 - fragColor.a);
		fragColor.g = fragColor.g * fragColor.a + teamcolor.g * ( 1.0 - fragColor.a);
		fragColor.b = fragColor.b * fragColor.a + teamcolor.b * ( 1.0 - fragColor.a);
		// fragColor.r = fragColor.r * (1.0 / 10.0 * mod(10.0, float(t)));
		// fragColor.a = 1.0 - mod(float(timeStamp), 100.0);
		fragColor.a = 1.0;
		gl_FragColor = fragColor;
		// gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
	}
</script>

<script type="text/javascript">
"use strict";

let ambientLight, pointLight;
let userCamera;
let shaderExampleScene;
let shaderExampleRenderer;
let moveX,moveY,moveZ;
let moveSpeedX = 1;
let moveSpeedY = 1;
let moveSpeedZ = 1;
let posXValue = -4;
let posYValue = 9;
let posZValue = 2;
let moveXMinus, moveYMinus, moveZMinus;
let enableTurn = false;
let enableTurnCamera = false;
let turnX = -0.60;
let turnY = -2.00;
let turnZ = 0.00;
let panoXTurn = 3.14;

let raycaster;
let mouse;
let objects = []; // all objects that are interactable;
let debugMode = true;

let team1KnightUniforms = {
		textureKnight:
		{
			type: "t",
			value: THREE
				.ImageUtils
				.loadTexture("objects/customObjs/knight/Myknight.png")
		},
		teamcolor:
		{
			value: new THREE.Color(options.teamcolor1)
		},
		timeStamp:
		{
			value: Date.now()
		},
		beamOff:
		{
			value: true
		}
	};

let team1KnightMaterial = new THREE.ShaderMaterial(
	{
		vertexShader:
			document
			.getElementById("teamcolorVertexShader")
			.textContent,
		fragmentShader:
			document
			.getElementById("teamcolorFragmentShader")
			.textContent,
		uniforms: team1KnightUniforms,
		// wireframe: true
	}
);

let team2knightUniforms = {
		textureKnight:
		{
			type: "t",
			value: THREE
				.ImageUtils
				.loadTexture("objects/customObjs/knight/Myknight.png")
		},
		teamcolor:
		{
			value: new THREE.Color(options.teamcolor2)
		},
		timeStamp:
		{
			value: Date.now()
		},
		beamOff:
		{
			value: false
		}
	};

let team2KnightMaterial = new THREE.ShaderMaterial(
	{
		vertexShader:
			document
			.getElementById("teamcolorVertexShader")
			.textContent,
		fragmentShader:
			document
			.getElementById("teamcolorFragmentShader")
			.textContent,
		uniforms: team2knightUniforms,
		// wireframe: true
	}
);

init();

function init()
{
	//Perspektivische Kammera wird erstellt
	userCamera = new THREE.PerspectiveCamera(
		80,
		window.innerWidth / window.innerHeight,
		1,
		1000
	);
	userCamera.rotation.order = 'YXZ';

	// Scene erstellen
	shaderExampleScene = new THREE.Scene();

	// Hintergrund Farbe wird gesetzt
	let backgroundColor = new THREE.Color(0x5060AA);
	shaderExampleScene.background = backgroundColor;

	// add Lightsources
	ambientLight = new THREE.AmbientLight( 0x505050 , 1.0);
	shaderExampleScene.add(ambientLight);
	pointLight = new THREE.PointLight( 0xFFFFFF, 1.0, 0.0, 1.0);
	pointLight.position.set(-50, 50, 50);
	shaderExampleScene.add(pointLight);

	let hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
	hemiLight.color.setHSL( 0.6, 1, 0.6 );
	hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
	hemiLight.position.set( 0, 50, 0 );
	shaderExampleScene.add( hemiLight );

	if (debugMode)
	{
		let pointLightHelper = new THREE.PointLightHelper( pointLight, 10 );
		shaderExampleScene.add( pointLightHelper );
		let hemiLightHelper = new THREE.HemisphereLightHelper( hemiLight, 10 );
		shaderExampleScene.add( hemiLightHelper );
		let AxisHelper = new THREE.AxisHelper(500);
		shaderExampleScene.add( AxisHelper );
	}

	// add floor
	let groundGeo = new THREE.PlaneBufferGeometry( 10000, 10000 );
	let groundMat = new THREE.MeshPhongMaterial(
		{
			color: 0xffffff,
			specular: 0x050505
		}
	);
	groundMat.color.setHSL( 0.095, 1, 0.75 );
	let ground = new THREE.Mesh( groundGeo, groundMat );
	ground.rotation.x = -Math.PI/2;
	shaderExampleScene.add( ground );
	ground.receiveShadow = true;

	// add knights
	let objFile = "objects/customObjs/knight/Myknight.obj";
	let loader = new THREE.OBJLoader();
	loader.load( objFile, function( object )
	{
		object.children.forEach( function (obj, index)
		{
			obj.material = team1KnightMaterial;
			obj.position.x = 5;
			obj.position.z = 5;
			obj.teamNumber = 1;
			objects.push( obj );
		});

		shaderExampleScene.add(object);
	});

	loader.load( objFile, function( object )
	{
		object.children.forEach( function (obj, index)
		{
			obj.material = team2KnightMaterial;
			obj.position.x = 5;
			obj.position.z = 10;
			obj.teamNumber = 2;
			objects.push( obj );
		});


		shaderExampleScene.add(object);
	});

	loader.load( objFile, function( object )
	{
		object.children.forEach( function (obj, index)
		{
			obj.material = team1KnightMaterial;
			obj.position.x = 10;
			obj.position.z = 5;
			obj.teamNumber = 1;
			objects.push( obj );
		});

		shaderExampleScene.add(object);
	});

	loader.load( objFile, function( object )
	{
		object.children.forEach( function (obj, index)
		{
			obj.material = team2KnightMaterial;
			obj.position.x = 10;
			obj.position.z = 10;
			obj.teamNumber = 2;
			objects.push( obj );
		});


		shaderExampleScene.add(object);
	});

	if (debugMode)
	{
		let geometry = new THREE.BoxGeometry( 1, 1, 1 );
		let material = new THREE.MeshLambertMaterial( { color: 'green' } );
		let cube = new THREE.Mesh( geometry, material );
		cube.position.z = 2;
		cube.position.y = 1;
		shaderExampleScene.add(cube);
		objects.push( cube );

		let geometry2 = new THREE.BoxGeometry( 1, 1, 1 );
		let cube2 = new THREE.Mesh( geometry, team1KnightMaterial );
		cube2.position.z = 4;
		cube2.position.y = 1;
		shaderExampleScene.add(cube2);
		objects.push( cube2 );

		let geometry3 = new THREE.BoxGeometry( 1, 1, 1 );
		let cube3 = new THREE.Mesh( geometry, team2KnightMaterial );
		cube3.position.z = 6;
		cube3.position.y = 1;
		shaderExampleScene.add(cube3);
		objects.push( cube3 );
	}

	// setup renderer
	shaderExampleRenderer = new THREE.WebGLRenderer( {antialias: true, alpha: true} );
	shaderExampleRenderer.setPixelRatio( window.devicePixelRatio );
	shaderExampleRenderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( shaderExampleRenderer.domElement );

	moveX = false;
	moveY = false;
	moveZ = false;
	moveXMinus = false;
	moveYMinus = false;
	moveZMinus = false;

	raycaster = new THREE.Raycaster();
	mouse = new THREE.Vector2();

	window.addEventListener( 'resize', onWindowResize, false );
	window.addEventListener( 'keydown', onKeyPressed, false );
	window.addEventListener( 'keyup', onKeyUp, false );
	window.addEventListener( 'mouseup', onMouseUp, false );
	window.addEventListener( 'mousemove', onMouseMove, false );
	window.addEventListener( 'mousedown', onMouseDown, false );
	window.addEventListener( 'mouseup', onMouseUp, false );
	window.addEventListener( 'contextmenu', onContextMenu, false );

	// start the render loop
	animate();
}

function onWindowResize()
{
	userCamera.aspect = window.innerWidth / window.innerHeight;
	userCamera.updateProjectionMatrix();
	shaderExampleRenderer.setSize( window.innerWidth, window.innerHeight );
}

function onKeyPressed(event)
{
	switch(event.keyCode)
	{
		case 87://W
			moveX = true;
		break;
		case 65://A
			moveZMinus = true;
		break;
		case 83://S
			moveXMinus = true;
		break;
		case 68://D
			moveZ = true;
		break;
		case 32://space
			moveY = true;
		break;
		case 16://shiftleft
			moveYMinus = true;
		break;
	}
}

function onKeyUp(event)
{
	switch(event.keyCode)
	{
		case 87://W
			moveX = false;
		break;
		case 65://A
			moveZMinus = false;
		break;
		case 83://S
			moveXMinus = false;
		break;
		case 68://D
			moveZ = false;
		break;
		case 32://space
			moveY = false;
		break;
		case 16://shiftleft
			moveYMinus = false;
		break;
	}
}

function animate()
{
	team1KnightUniforms.timeStamp.value = Date.now();
	team2knightUniforms.timeStamp.value = Date.now();
	shaderExampleRenderer.render( shaderExampleScene, userCamera );

	if (debugMode)
	{
		if(moveX)
		{
			posXValue += moveSpeedX;
		}
		if(moveY)
		{
			posYValue += moveSpeedY;
		}
		if(moveZ)
		{
			posZValue += moveSpeedZ;
		}
		if(moveXMinus)
		{
			posXValue -= moveSpeedX;
		}
		if(moveYMinus)
		{
			posYValue -= moveSpeedY;
		}
		if(moveZMinus)
		{
			posZValue -= moveSpeedZ;
		}
	}

	userCamera.rotation.x = turnX;
	userCamera.rotation.y = turnY;
	userCamera.rotation.z = turnZ;

	if (debugMode)
	{
		userCamera.position.x = posXValue;
		userCamera.position.y = posYValue;
		userCamera.position.z = posZValue;
	}

	requestAnimationFrame( animate );
}

function onMouseMove( event )
{
	let movementX = event.movementX
		|| event.mozMovementX
		|| event.webkitMovementX
		|| 0;
	let movementY = event.movementY
		|| event.mozMovementY
		|| event.webkitMovementY
		|| 0;

	if (enableTurn == true)
	{
		// yes they are inverted and this needs to be
		turnX += movementY * -0.002;
		turnY += movementX * -0.002;
	}
}

function onMouseDown( event ) { enableTurn = true; }

function onMouseUp  ( event )
{
	enableTurn = false;
	enableTurnCamera = false;
}

function onContextMenu ( event ){ event.preventDefault();}

function onMouseMove( event )
{
		let movementX = event.movementX
			|| event.mozMovementX
			|| event.webkitMovementX
			|| 0;
		let movementY = event.movementY
			|| event.mozMovementY
			|| event.webkitMovementY
			|| 0;

		if (enableTurnCamera == true)
		{
			// yes they are inverted and this needs to be
			turnX += movementY * -0.0035;
			turnY += movementX * -0.005;
		}
		if(enableTurn == true)
		{
			panoXTurn += movementX * -0.002;
		}
}

function onMouseDown( event )
{
	let isRightMb;
	if("which" in event){isRightMb = event.which == 3}
	else if("button" in event){isRightMb = event.button == 2}
	if(!isRightMb){enableTurn = true;}
	else{ enableTurnCamera = true;}
}

function onClick  ( event )
{
	mouse.x = (
		event.clientX / shaderExampleRenderer.domElement.clientWidth
		) * 2 - 1;
	mouse.y = - (
		event.clientY / shaderExampleRenderer.domElement.clientHeight
		) * 2 + 1;

	raycaster.setFromCamera( mouse, userCamera );
	var intersects = raycaster.intersectObjects( objects );
	if ( intersects.length > 0 )
	{
		switch(intersects[0].object.name)
		{
			default:
			break;
		}
	}
}
</script>
</body>
</html>