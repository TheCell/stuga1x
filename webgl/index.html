<!DOCTYPE html>
<html>
<head>
<title>
	Shader Scene
</title>
<meta charset="utf-8" />
<meta
	name="viewport"
	content="width=device-width,
		user-scalable=no,
		minimum-scale=1.0,
		maximum-scale=1.0"
/>

<style>
	body
	{
		margin: 0px;
		background-color: #AAA;
		overflow: hidden;
	}
</style>
</head>

<body>
<script src="js/three.js"></script>
<script src="js/OBJLoader.js"></script>
<script type="x-shader/x-vertex" id="teamcolorVertexShader">
	precision mediump float;

	void main()
	{
		vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
		gl_Position = projectionMatrix * modelViewPosition;
	}
</script>
<script type="x-shader/x-fragment" id="teamcolorFragmentShader">
	precision mediump float;

	void main()
	{
		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
	}
</script>

<script type="text/javascript">
"use strict";

let ambientLight, pointLight;
let userCamera;
let shaderExampleScene;
let shaderExampleRenderer;
let moveX,moveY,moveZ;
let moveSpeedX = 1;
let moveSpeedY = 1;
let moveSpeedZ = 1;
let posXValue = -4;
let posYValue = 2;
let posZValue = 7;
let moveXMinus, moveYMinus, moveZMinus;
let enableTurn = false;
let enableTurnCamera = false;
let turnX = 0.00;
let turnY = -1.5;
let turnZ = 0.00;
let panoXTurn = 3.14;

let raycaster;
let mouse;
let objects = []; // all objects that are interactable;
let debugMode = true;

var teamColorMat = new THREE.ShaderMaterial(
	{
		vertexShader:
			document
			.getElementById("teamcolorVertexShader")
			.textContent,
		fragmentShader:
			document
			.getElementById("teamcolorFragmentShader")
			.textContent
	}
);

init();

function init()
{
	//Perspektivische Kammera wird erstellt
	userCamera = new THREE.PerspectiveCamera(
		80,
		window.innerWidth / window.innerHeight,
		1,
		1000
	);
	userCamera.rotation.order = 'YXZ';

	// Scene erstellen
	shaderExampleScene = new THREE.Scene();

	// Hintergrund Farbe wird gesetzt
	let backgroundColor = new THREE.Color(0x5060AA);
	shaderExampleScene.background = backgroundColor;

	// add Lightsources
	ambientLight = new THREE.AmbientLight( 0x505050 , 1.0);
	shaderExampleScene.add(ambientLight);
	pointLight = new THREE.PointLight( 0xFFFFFF, 1.0, 0.0, 1.0);
	pointLight.position.set(-300, 100, 200);
	shaderExampleScene.add(pointLight);

	if (debugMode)
	{
		let AxisHelper = new THREE.AxisHelper(500);
		shaderExampleScene.add( AxisHelper );
	}

	let objFile = "objects/customObjs/knight/Myknight.obj";
	let loader = new THREE.OBJLoader();
	loader.load( objFile, function( object )
	{
		object.children.forEach( function (obj, index)
		{
			obj.material = teamColorMat;
			obj.position.x = 5;
			obj.position.z = 5;
			objects.push( obj );
		});

		shaderExampleScene.add(object);
	});

	if (debugMode)
	{
		let geometry = new THREE.BoxGeometry( 1, 1, 1 );
		let material = new THREE.MeshLambertMaterial( { color: 'green' } );
		let cube = new THREE.Mesh( geometry, material );
		cube.position.z = 2;
		shaderExampleScene.add(cube);
		objects.push( cube );

		let geometry2 = new THREE.BoxGeometry( 1, 1, 1 );
		let cube2 = new THREE.Mesh( geometry, teamColorMat );
		cube2.position.z = 4;
		shaderExampleScene.add(cube2);
		objects.push( cube2 );
	}

	// setup renderer
	shaderExampleRenderer = new THREE.WebGLRenderer( {antialias: true} );
	shaderExampleRenderer.setPixelRatio( window.devicePixelRatio );
	shaderExampleRenderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( shaderExampleRenderer.domElement );

	moveX = false;
	moveY = false;
	moveZ = false;
	moveXMinus = false;
	moveYMinus = false;
	moveZMinus = false;

	raycaster = new THREE.Raycaster();
	mouse = new THREE.Vector2();

	window.addEventListener( 'resize', onWindowResize, false );
	window.addEventListener( 'keydown', onKeyPressed, false );
	window.addEventListener( 'keyup', onKeyUp, false );
	window.addEventListener( 'mouseup', onMouseUp, false );
	window.addEventListener( 'mousemove', onMouseMove, false );
	window.addEventListener( 'mousedown', onMouseDown, false );
	window.addEventListener( 'mouseup', onMouseUp, false );
	window.addEventListener( 'contextmenu', onContextMenu, false );

	// start the render loop
	animate();
}

function onWindowResize()
{
	userCamera.aspect = window.innerWidth / window.innerHeight;
	userCamera.updateProjectionMatrix();
	shaderExampleRenderer.setSize( window.innerWidth, window.innerHeight );
}

function onKeyPressed(event)
{
	switch(event.keyCode)
	{
		case 87://W
			moveX = true;
		break;
		case 65://A
			moveZMinus = true;
		break;
		case 83://S
			moveXMinus = true;
		break;
		case 68://D
			moveZ = true;
		break;
		case 32://space
			moveY = true;
		break;
		case 16://shiftleft
			moveYMinus = true;
		break;
	}
}

function onKeyUp(event)
{
	switch(event.keyCode)
	{
		case 87://W
			moveX = false;
		break;
		case 65://A
			moveZMinus = false;
		break;
		case 83://S
			moveXMinus = false;
		break;
		case 68://D
			moveZ = false;
		break;
		case 32://space
			moveY = false;
		break;
		case 16://shiftleft
			moveYMinus = false;
		break;
	}
}

function animate()
{
	shaderExampleRenderer.render( shaderExampleScene, userCamera );

	if (debugMode)
	{
		if(moveX)
		{
			posXValue += moveSpeedX;
		}
		if(moveY)
		{
			posYValue += moveSpeedY;
		}
		if(moveZ)
		{
			posZValue += moveSpeedZ;
		}
		if(moveXMinus)
		{
			posXValue -= moveSpeedX;
		}
		if(moveYMinus)
		{
			posYValue -= moveSpeedY;
		}
		if(moveZMinus)
		{
			posZValue -= moveSpeedZ;
		}
	}

	userCamera.rotation.x = turnX;
	userCamera.rotation.y = turnY;
	userCamera.rotation.z = turnZ;

	if (debugMode)
	{
		userCamera.position.x = posXValue;
		userCamera.position.y = posYValue;
		userCamera.position.z = posZValue;
	}

	requestAnimationFrame( animate );
}

function onMouseMove( event )
{
	let movementX = event.movementX
		|| event.mozMovementX
		|| event.webkitMovementX
		|| 0;
	let movementY = event.movementY
		|| event.mozMovementY
		|| event.webkitMovementY
		|| 0;

	if (enableTurn == true)
	{
		// yes they are inverted and this needs to be
		turnX += movementY * -0.002;
		turnY += movementX * -0.002;
	}
}

function onMouseDown( event ) { enableTurn = true; }

function onMouseUp  ( event )
{
	enableTurn = false;
	enableTurnCamera = false;
}

function onContextMenu ( event ){ event.preventDefault();}

function onMouseMove( event )
{
		let movementX = event.movementX
			|| event.mozMovementX
			|| event.webkitMovementX
			|| 0;
		let movementY = event.movementY
			|| event.mozMovementY
			|| event.webkitMovementY
			|| 0;

		if (enableTurnCamera == true)
		{
			// yes they are inverted and this needs to be
			turnX += movementY * -0.0035;
			turnY += movementX * -0.005;
		}
		if(enableTurn == true)
		{
			panoXTurn += movementX * -0.002;
		}
}

function onMouseDown( event )
{
	let isRightMb;
	if("which" in event){isRightMb = event.which == 3}
	else if("button" in event){isRightMb = event.button == 2}
	if(!isRightMb){enableTurn = true;}
	else{ enableTurnCamera = true;}
}

function onClick  ( event )
{
	mouse.x = (
		event.clientX / shaderExampleRenderer.domElement.clientWidth
		) * 2 - 1;
	mouse.y = - (
		event.clientY / shaderExampleRenderer.domElement.clientHeight
		) * 2 + 1;

	raycaster.setFromCamera( mouse, userCamera );
	var intersects = raycaster.intersectObjects( objects );
	if ( intersects.length > 0 )
	{
		switch(intersects[0].object.name)
		{
			default:
			break;
		}
	}
}
</script>
</body>
</html>